C51 COMPILER V9.54   HWMK                                                                  05/15/2021 13:44:47 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE HWMK
OBJECT MODULE PLACED IN .\Objects\hwmk.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Keil_v5\C51\BIN\C51.EXE hwmk.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND P
                    -RINT(.\Listings\hwmk.lst) TABS(2) OBJECT(.\Objects\hwmk.obj)

line level    source

   1          #include <reg52.h> //51ͷļ
   2          #include <QX_A11.h>//QX-A51Сļ
   3          #include "delay.h"
   4          /*====================================
   5           Զ
   6          ====================================*/
   7          typedef unsigned char INT8U;
   8          typedef unsigned char uchar;
   9          typedef unsigned int INT16U;
  10          typedef unsigned int uint;
  11          
  12          /*====================================
  13           Ӳӿλ
  14          ====================================*/
  15          sbit IR  = P3^2;     //ݽӿ ⲿжO
  16          
  17          uchar IRtime;     //ߵƽʱ䣨
  18          uchar IRcord[4];    //ڴ4ֽڵݣû2ֽ+ֵ2ֽڣ
  19          uchar IRdata[33];   //ڴ33λݣһλΪû16+ֵ16
  20          bit IRpro_ok, IRok;  //һں4ֽϡIRokΪ
  21          
  22          void init()    //ʼʱ0 ⲿж0
  23          {
  24   1        TMOD = 0x02; //ʱ0ʽ28λԶװ
  25   1        TH0 = 0x00;  //8λװ0ôʱһεʱ256
  26   1        TL0 = 0x00;
  27   1        EA = 1;      //ж
  28   1        ET0 = 1;     //ʱ0ж
  29   1        TR0 = 1;     //ʱ0
  30   1        IT0 = 1;     //ⲿж0Ϊشʽһ½شһ
  31   1        EX0 = 1;     //ⲿж0
  32   1      }
  33          
  34          void time0() interrupt 1   //嶨ʱ0
  35          {
  36   1        IRtime++;          //1Ϊ278us
  37   1      }
  38          
  39          void int0() interrupt 0       //ⲿж0
  40          {
  41   1        static uchar i;       //  ̬ڻִеʱ򲻻ᶪʧֵiڰ33θߵƽĳʱ
             -IRdata
  42   1        static bit startflag;   //ʼ־λ
  43   1        if(startflag)       //ʼ
  44   1        {
  45   2          if( (IRtime < 53) && (IRtime >= 32) ) /*жǷ룬׵ƽ9000us+4500us 
  46   2          Լ11.0592NECЭ8000-10000+4000-5000 
  47   2          Ѿôiᱻ0ͻῪʼδ*/
  48   2            i = 0;         //ôִi=0浽IRdataĵһλ
  49   2          IRdata[i] = IRtime;      //T0ʱ浽浽ж
  50   2          IRtime = 0;        //㣬һ½صʱڴ
  51   2          i++;           //Ĵ
  52   2          if(i == 33)          //34 ±Ǵ0ʼi33ʾִ34
  53   2          {
C51 COMPILER V9.54   HWMK                                                                  05/15/2021 13:44:47 PAGE 2   

  54   3            IRok = 1;        //ôʾ
  55   3            i = 0;         //׼´δ
  56   3          }
  57   2        }
  58   1        else      
  59   1        {
  60   2          IRtime = 0;          //뿪ʼ㿪ʼ
  61   2          startflag = 1;       //ʼ־λ1
  62   2        }
  63   1      }
  64          
  65          void IRcordpro()           //ȡ33ݽ
  66          {
  67   1        uchar i, j, k, cord, value; /*iڴ4ֽڣjڴһֽÿһλk33еһλ
  68   1        cordȡʱжǷ1ʱ*/
  69   1        k = 1;            //ӵһλʼȡ
  70   1        for(i = 0; i < 4; i++)
  71   1        {
  72   2          for(j = 0; j < 8; j++)
  73   2          {
  74   3            cord = IRdata[k];     //cord
  75   3            if(cord > 5)      //11.0592t0ΪԼ278us*5=1390ôжΪ1
  76   3            value = value | 0x80; /*յʱȽλ
  77   3            λȷŵvalueλں0x08λһ
  78   3            ıvaluaλֵֻλΪ1*/
  79   3            if(j < 7)
  80   3            {
  81   4              value = value >> 1; //valueλν8λݡ
  82   4            }
  83   3            k++;        //ÿִһλ1
  84   3          }
  85   2          IRcord[i] = value;     //ÿһֽڰIRcordС
  86   2          value = 0;         //value´ڴ
  87   2        }
  88   1        IRpro_ok = 1;          //4ֽںIRpro ok1ʾ 
  89   1      }
  90          /*PWMʹ Сǰ*/
  91          void forward()
  92          {
  93   1        left_motor_go; //ǰ
  94   1        right_motor_go; //ҵǰ
  95   1      }
  96          
  97            
  98          /*PWMʹ С*/
  99          void backward()
 100          {
 101   1        left_motor_back; //
 102   1        right_motor_back; //ҵ  
 103   1      }
 104          
 105          
 106          /*PWMʹ Сת*/
 107          void left_run()
 108          {
 109   1        left_motor_stops; //ֹͣ
 110   1        right_motor_go; //ҵǰ  
 111   1      }
 112          
 113          
 114          /*PWMʹ Сת*/
 115          void right_run()
C51 COMPILER V9.54   HWMK                                                                  05/15/2021 13:44:47 PAGE 3   

 116          {
 117   1        right_motor_stops;//ҵֹͣ
 118   1        left_motor_go;    //ǰ
 119   1      }
 120          
 121          
 122          /*Сֹͣ*/
 123          void stop()
 124          {
 125   1        right_motor_stops;//ҵֹͣ
 126   1        left_motor_stops; //ֹͣ  
 127   1      }
 128          
 129          void hwmk()
 130          {
 131   1        init(); //ִгʼʱ0ⲿж0
 132   1        Left_moto_pwm = Right_moto_pwm = 1;//ʹҵ
 133   1        while(1)  //ѭ
 134   1        {
 135   2          if(IRok)    //жǷ                    
 136   2          {   
 137   3            IRcordpro();//4ֽڵ
 138   3            IRok = 0; //µȴ
 139   3            if(IRpro_ok) //жǷ  
 140   3            {
 141   4                  switch(IRcord[2])
 142   4                {
 143   5                   case 0x18:  stop(); DelayMs(200); forward();        //ǰ
 144   5                           break;
 145   5                   case 0x52:  stop(); DelayMs(200); backward();         //  
 146   5                           break;
 147   5                   case 0x08:  stop(); DelayMs(200); left_run();       //ת
 148   5                           break;
 149   5                 case 0x5A:  stop(); DelayMs(200); right_run();        //ת
 150   5                           break;
 151   5                 case 0x1C:  stop();           //ֹͣ
 152   5                           break;
 153   5                 default:break;
 154   5                }
 155   4              IRpro_ok = 0;
 156   4            }
 157   3          } 
 158   2        }
 159   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    280    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     39    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
