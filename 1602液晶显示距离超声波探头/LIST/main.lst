C51 COMPILER V9.54   MAIN                                                                  05/07/2021 15:56:06 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\OBJ\main.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND P
                    -RINT(.\LIST\main.lst) TABS(2) OBJECT(.\OBJ\main.obj)

line level    source

   1          
   2           #include <reg52.h>
   3           #include <stdio.h>
   4           #include <math.h>
   5           #include "1602.h"
   6           #include "delay.h"
   7          
   8           sbit TRIGL = P1^0 ;
   9           sbit ECHOL = P1^1 ;
  10           sbit TRIGB = P1^2 ;
  11           sbit ECHOB = P1^3 ;
  12           sbit TRIGR = P1^4 ;
  13           sbit ECHOR = P1^5 ;
  14           unsigned char DisTempData[16];
  15          
  16          /*------------------------------------------------
  17                              定时器0初始化
  18          ------------------------------------------------*/
  19          void TIM0init(void)
  20          {
  21   1      
  22   1        TMOD|= 0x01;//定时器0工作方式1
  23   1        TH0=0x00;    
  24   1        TL0=0x00; 
  25   1        ET0=1;
  26   1        EA=1;
  27   1      }
  28          /*------------------------------------------------
  29                              主函数
  30          ------------------------------------------------*/
  31          main()
  32          { 
  33   1               //距离变量
  34   1        TIM0init();    //初始化定时器0
  35   1        LCD_Init();    //初始化LCD
  36   1        while(1)
  37   1        {
  38   2         float S,S1,S2,S3,S4,S5,arr[5],temp;
  39   2         int i, j;
  40   2      /*------------------------------------------------
  41   2                     右边测距
  42   2      ------------------------------------------------*/
  43   2         /*one*/
  44   2         TRIGR=1;       //触发信号是高电平脉冲，宽度大于10us
  45   2         DelayUs2x(10);
  46   2         TRIGR=0;
  47   2         while(!ECHOR); //等待高电平
  48   2         TR0=1;
  49   2         while(ECHOR);  //等待低电平
  50   2         TR0=0;
  51   2         S1=TH0*256+TL0;//取出定时器值高8位和低8位合并
  52   2         S1=S1/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
  53   2         arr[0]=S1;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
  54   2         TH0=0;
C51 COMPILER V9.54   MAIN                                                                  05/07/2021 15:56:06 PAGE 2   

  55   2         TL0=0;        //清除定时器0寄存器中的值
  56   2         /*two*/
  57   2         TRIGR=1;       //触发信号是高电平脉冲，宽度大于10us
  58   2         DelayUs2x(10);
  59   2         TRIGR=0;
  60   2         while(!ECHOR); //等待高电平
  61   2         TR0=1;
  62   2         while(ECHOR);  //等待低电平
  63   2         TR0=0;
  64   2         S2=TH0*256+TL0;//取出定时器值高8位和低8位合并
  65   2         S2=S2/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
  66   2         arr[1]=S2;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
  67   2         TH0=0;
  68   2         TL0=0;        //清除定时器0寄存器中的值
  69   2         /*third*/
  70   2         TRIGR=1;       //触发信号是高电平脉冲，宽度大于10us
  71   2         DelayUs2x(10);
  72   2         TRIGR=0;
  73   2         while(!ECHOR); //等待高电平
  74   2         TR0=1;
  75   2         while(ECHOR);  //等待低电平
  76   2         TR0=0;
  77   2         S3=TH0*256+TL0;//取出定时器值高8位和低8位合并
  78   2         S3=S3/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
  79   2         arr[2]=S3;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
  80   2         TH0=0;
  81   2         TL0=0;        //清除定时器0寄存器中的值
  82   2         /*four*/
  83   2         TRIGR=1;       //触发信号是高电平脉冲，宽度大于10us
  84   2         DelayUs2x(10);
  85   2         TRIGR=0;
  86   2         while(!ECHOR); //等待高电平
  87   2         TR0=1;
  88   2         while(ECHOR);  //等待低电平
  89   2         TR0=0;
  90   2         S4=TH0*256+TL0;//取出定时器值高8位和低8位合并
  91   2         S4=S4/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
  92   2         arr[3]=S4;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
  93   2         TH0=0;
  94   2         TL0=0;        //清除定时器0寄存器中的值
  95   2         /*five*/
  96   2         TRIGR=1;       //触发信号是高电平脉冲，宽度大于10us
  97   2         DelayUs2x(10);
  98   2         TRIGR=0;
  99   2         while(!ECHOR); //等待高电平
 100   2         TR0=1;
 101   2         while(ECHOR);  //等待低电平
 102   2         TR0=0;
 103   2         S5=TH0*256+TL0;//取出定时器值高8位和低8位合并
 104   2         S5=S4/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
 105   2         arr[4]=S5;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
 106   2         TH0=0;
 107   2         TL0=0;        //清除定时器0寄存器中的值
 108   2         /*try*/
 109   2      
 110   2              for (i = 0; i < 5 - 1; i++)
 111   2                      for (j = 0; j < 5 - 1 - i; j++)
 112   2                              if (arr[j] > arr[j + 1])
 113   2                                {
 114   3                                      temp = arr[j];
 115   3                                      arr[j] = arr[j + 1];
 116   3                                      arr[j + 1] = temp;
C51 COMPILER V9.54   MAIN                                                                  05/07/2021 15:56:06 PAGE 3   

 117   3                                }
 118   2         /*try*/
 119   2         S=(arr[1]+arr[2]+arr[3])/3;
 120   2         sprintf(DisTempData,"R=%6.2f CM     ",S);//打印输出结果
 121   2         LCD_Write_String(0,0,DisTempData);       //在液晶屏上显示
 122   2         DelayMs(500); 
 123   2      /*------------------------------------------------
 124   2                  左边测距
 125   2      ------------------------------------------------*/ 
 126   2      //   /*one*/
 127   2      //   TRIGR=1;       //触发信号是高电平脉冲，宽度大于10us
 128   2      //   DelayUs2x(10);
 129   2      //   TRIGR=0;
 130   2      //   while(!ECHOL); //等待高电平
 131   2      //   TR0=1;
 132   2      //   while(ECHOL);  //等待低电平
 133   2      //   TR0=0;
 134   2      //   S1=TH0*256+TL0;//取出定时器值高8位和低8位合并
 135   2      //   S1=S1/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
 136   2      //   arr[0]=S1;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
 137   2      //   TH0=0;
 138   2      //   TL0=0;        //清除定时器0寄存器中的值
 139   2      //   /*two*/
 140   2      //   TRIGR=1;       //触发信号是高电平脉冲，宽度大于10us
 141   2      //   DelayUs2x(10);
 142   2      //   TRIGR=0;
 143   2      //   while(!ECHOL); //等待高电平
 144   2      //   TR0=1;
 145   2      //   while(ECHOL);  //等待低电平
 146   2      //   TR0=0;
 147   2      //   S2=TH0*256+TL0;//取出定时器值高8位和低8位合并
 148   2      //   S2=S2/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
 149   2      //   arr[1]=S2;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
 150   2      //   TH0=0;
 151   2      //   TL0=0;        //清除定时器0寄存器中的值
 152   2      //   /*third*/
 153   2      //   TRIGR=1;       //触发信号是高电平脉冲，宽度大于10us
 154   2      //   DelayUs2x(10);
 155   2      //   TRIGR=0;
 156   2      //   while(!ECHOL); //等待高电平
 157   2      //   TR0=1;
 158   2      //   while(ECHOL);  //等待低电平
 159   2      //   TR0=0;
 160   2      //   S3=TH0*256+TL0;//取出定时器值高8位和低8位合并
 161   2      //   S3=S3/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
 162   2      //   arr[2]=S3;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
 163   2      //   TH0=0;
 164   2      //   TL0=0;        //清除定时器0寄存器中的值
 165   2      //   /*four*/
 166   2      //   TRIGR=1;       //触发信号是高电平脉冲，宽度大于10us
 167   2      //   DelayUs2x(10);
 168   2      //   TRIGR=0;
 169   2      //   while(!ECHOL); //等待高电平
 170   2      //   TR0=1;
 171   2      //   while(ECHOL);  //等待低电平
 172   2      //   TR0=0;
 173   2      //   S4=TH0*256+TL0;//取出定时器值高8位和低8位合并
 174   2      //   S4=S4/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
 175   2      //   arr[3]=S4;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
 176   2      //   TH0=0;
 177   2      //   TL0=0;        //清除定时器0寄存器中的值
 178   2      //   /*five*/
C51 COMPILER V9.54   MAIN                                                                  05/07/2021 15:56:06 PAGE 4   

 179   2      //   TRIGR=1;       //触发信号是高电平脉冲，宽度大于10us
 180   2      //   DelayUs2x(10);
 181   2      //   TRIGR=0;
 182   2      //   while(!ECHOL); //等待高电平
 183   2      //   TR0=1;
 184   2      //   while(ECHOL);  //等待低电平
 185   2      //   TR0=0;
 186   2      //   S5=TH0*256+TL0;//取出定时器值高8位和低8位合并
 187   2      //   S5=S4/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
 188   2      //   arr[4]=S5;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
 189   2      //   TH0=0;
 190   2      //   TL0=0;        //清除定时器0寄存器中的值
 191   2      //   /*try*/
 192   2      //        for (i = 0; i < 5 - 1; i++)
 193   2      //                for (j = 0; j < 5 - 1 - i; j++)
 194   2      //                        if (arr[j] > arr[j + 1])
 195   2      //                          {
 196   2      //                                temp = arr[j];
 197   2      //                                arr[j] = arr[j + 1];
 198   2      //                                arr[j + 1] = temp;
 199   2      //                          }
 200   2      //   /*try*/
 201   2      //   S=(arr[1]+arr[2]+arr[3])/3;
 202   2      //   sprintf(DisTempData,"L=%6.2f CM     ",S);//打印输出结果
 203   2      //   LCD_Write_String(0,0,DisTempData);       //在液晶屏上显示
 204   2      //   DelayMs(1000); 
 205   2        }
 206   1       }
 207          
 208          /*------------------------------------------------
 209                           定时器中断子程序
 210          ------------------------------------------------*/
 211          void Timer0_isr(void) interrupt 1
 212          {
 213   1        ECHOL=0;
 214   1        ECHOB=0;
 215   1        ECHOR=0;
 216   1      }
 217          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    665    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16      52
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
