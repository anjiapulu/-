C51 COMPILER V9.54   MAIN                                                                  05/07/2021 16:45:38 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\OBJ\main.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND P
                    -RINT(.\LIST\main.lst) TABS(2) OBJECT(.\OBJ\main.obj)

line level    source

   1          
   2           #include <reg52.h>
   3           #include <stdio.h>
   4           #include <math.h>
   5           #include "1602.h"
   6           #include "delay.h"
   7          
   8           sbit TRIGL = P1^0 ;
   9           sbit ECHOL = P1^1 ;
  10           sbit TRIGB = P1^2 ;
  11           sbit ECHOB = P1^3 ;
  12           sbit TRIGR = P1^4 ;
  13           sbit ECHOR = P1^5 ;
  14           unsigned char DisTempData[7];
  15          /*------------------------------------------------
  16                              定时器0初始化
  17          ------------------------------------------------*/
  18          void TIM0init(void)
  19          {
  20   1      
  21   1        TMOD|= 0x01;//定时器0工作方式1
  22   1        TH0=0x00;    
  23   1        TL0=0x00; 
  24   1        ET0=1;
  25   1        EA=1;
  26   1      }
  27          /*------------------------------------------------
  28                              主函数
  29          ------------------------------------------------*/
  30          main()
  31          { 
  32   1               /*距离变量*/
  33   1        TIM0init();    //初始化定时器0
  34   1        LCD_Init();    //初始化LCD
  35   1        while(1)
  36   1        {
  37   2         float S,S1,S2,S3,S4,S5,arr[5],temp;
  38   2         int i, j;
  39   2      /*------------------------------------------------
  40   2                     右边测距
  41   2      ------------------------------------------------*/
  42   2         /*one*/
  43   2         if(1)
  44   2        {
  45   3         TRIGR=1;       //触发信号是高电平脉冲，宽度大于10us
  46   3         DelayUs2x(10);
  47   3         TRIGR=0;
  48   3         while(!ECHOR); //等待高电平
  49   3         TR0=1;
  50   3         while(ECHOR);  //等待低电平
  51   3         TR0=0;
  52   3         S1=TH0*256+TL0;//取出定时器值高8位和低8位合并
  53   3         S1=S1/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
  54   3         arr[0]=S1;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
C51 COMPILER V9.54   MAIN                                                                  05/07/2021 16:45:38 PAGE 2   

  55   3         TH0=0;
  56   3         TL0=0;        //清除定时器0寄存器中的值
  57   3         /*two*/
  58   3         TRIGR=1;       //触发信号是高电平脉冲，宽度大于10us
  59   3         DelayUs2x(10);
  60   3         TRIGR=0;
  61   3         while(!ECHOR); //等待高电平
  62   3         TR0=1;
  63   3         while(ECHOR);  //等待低电平
  64   3         TR0=0;
  65   3         S2=TH0*256+TL0;//取出定时器值高8位和低8位合并
  66   3         S2=S2/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
  67   3         arr[1]=S2;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
  68   3         TH0=0;
  69   3         TL0=0;        //清除定时器0寄存器中的值
  70   3         /*third*/
  71   3         TRIGR=1;       //触发信号是高电平脉冲，宽度大于10us
  72   3         DelayUs2x(10);
  73   3         TRIGR=0;
  74   3         while(!ECHOR); //等待高电平
  75   3         TR0=1;
  76   3         while(ECHOR);  //等待低电平
  77   3         TR0=0;
  78   3         S3=TH0*256+TL0;//取出定时器值高8位和低8位合并
  79   3         S3=S3/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
  80   3         arr[2]=S3;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
  81   3         TH0=0;
  82   3         TL0=0;        //清除定时器0寄存器中的值
  83   3         /*four*/
  84   3         TRIGR=1;       //触发信号是高电平脉冲，宽度大于10us
  85   3         DelayUs2x(10);
  86   3         TRIGR=0;
  87   3         while(!ECHOR); //等待高电平
  88   3         TR0=1;
  89   3         while(ECHOR);  //等待低电平
  90   3         TR0=0;
  91   3         S4=TH0*256+TL0;//取出定时器值高8位和低8位合并
  92   3         S4=S4/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
  93   3         arr[3]=S4;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
  94   3         TH0=0;
  95   3         TL0=0;        //清除定时器0寄存器中的值
  96   3         /*five*/
  97   3         TRIGR=1;       //触发信号是高电平脉冲，宽度大于10us
  98   3         DelayUs2x(10);
  99   3         TRIGR=0;
 100   3         while(!ECHOR); //等待高电平
 101   3         TR0=1;
 102   3         while(ECHOR);  //等待低电平
 103   3         TR0=0;
 104   3         S5=TH0*256+TL0;//取出定时器值高8位和低8位合并
 105   3         S5=S4/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
 106   3         arr[4]=S5;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
 107   3         TH0=0;
 108   3         TL0=0;        //清除定时器0寄存器中的值
 109   3         /*try*/
 110   3      
 111   3              for (i = 0; i < 5 - 1; i++)
 112   3                      for (j = 0; j < 5 - 1 - i; j++)
 113   3                              if (arr[j] > arr[j + 1])
 114   3                                {
 115   4                                      temp = arr[j];
 116   4                                      arr[j] = arr[j + 1];
C51 COMPILER V9.54   MAIN                                                                  05/07/2021 16:45:38 PAGE 3   

 117   4                                      arr[j + 1] = temp;
 118   4                                }
 119   3         /*try*/
 120   3         S=(arr[1]+arr[2]+arr[3])/3;
 121   3         sprintf(DisTempData,"R=%6.2f",S);//打印输出结果
 122   3         LCD_Write_String(0,1,DisTempData);       //在液晶屏上显示
 123   3         DelayMs(500); 
 124   3         }
 125   2      /*------------------------------------------------
 126   2                  左边测距
 127   2      ------------------------------------------------*/ 
 128   2         if(1)
 129   2         {
 130   3         /*one*/
 131   3         TRIGL=1;      //触发信号是高电平脉冲，宽度大于10us
 132   3         DelayUs2x(10);
 133   3         TRIGL=0;
 134   3         while(!ECHOL); //等待高电平
 135   3         TR0=1;
 136   3         while(ECHOL);  //等待低电平
 137   3         TR0=0;
 138   3         S1=TH0*256+TL0;//取出定时器值高8位和低8位合并
 139   3         S1=S1/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
 140   3         arr[0]=S1;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
 141   3         TH0=0;
 142   3         TL0=0;        //清除定时器0寄存器中的值
 143   3         /*two*/
 144   3         TRIGL=1;       //触发信号是高电平脉冲，宽度大于10us
 145   3         DelayUs2x(10);
 146   3         TRIGL=0;
 147   3         while(!ECHOL); //等待高电平
 148   3         TR0=1;
 149   3         while(ECHOL);  //等待低电平
 150   3         TR0=0;
 151   3         S2=TH0*256+TL0;//取出定时器值高8位和低8位合并
 152   3         S2=S2/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
 153   3         arr[1]=S2;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
 154   3         TH0=0;
 155   3         TL0=0;        //清除定时器0寄存器中的值
 156   3         /*third*/
 157   3         TRIGL=1;       //触发信号是高电平脉冲，宽度大于10us
 158   3         DelayUs2x(10);
 159   3         TRIGL=0;
 160   3         while(!ECHOL); //等待高电平
 161   3         TR0=1;
 162   3         while(ECHOL);  //等待低电平
 163   3         TR0=0;
 164   3         S3=TH0*256+TL0;//取出定时器值高8位和低8位合并
 165   3         S3=S3/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
 166   3         arr[2]=S3;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
 167   3         TH0=0;
 168   3         TL0=0;        //清除定时器0寄存器中的值
 169   3         /*four*/
 170   3         TRIGL=1;       //触发信号是高电平脉冲，宽度大于10us
 171   3         DelayUs2x(10);
 172   3         TRIGL=0;
 173   3         while(!ECHOL); //等待高电平
 174   3         TR0=1;
 175   3         while(ECHOL);  //等待低电平
 176   3         TR0=0;
 177   3         S4=TH0*256+TL0;//取出定时器值高8位和低8位合并
 178   3         S4=S4/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
C51 COMPILER V9.54   MAIN                                                                  05/07/2021 16:45:38 PAGE 4   

 179   3         arr[3]=S4;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
 180   3         TH0=0;
 181   3         TL0=0;        //清除定时器0寄存器中的值
 182   3         /*five*/
 183   3         TRIGL=1;       //触发信号是高电平脉冲，宽度大于10us
 184   3         DelayUs2x(10);
 185   3         TRIGL=0;
 186   3         while(!ECHOL); //等待高电平
 187   3         TR0=1;
 188   3         while(ECHOL);  //等待低电平
 189   3         TR0=0;
 190   3         S5=TH0*256+TL0;//取出定时器值高8位和低8位合并
 191   3         S5=S4/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
 192   3         arr[4]=S5;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
 193   3         TH0=0;
 194   3         TL0=0;        //清除定时器0寄存器中的值
 195   3         /*try*/
 196   3              for (i = 0; i < 5 - 1; i++)
 197   3                      for (j = 0; j < 5 - 1 - i; j++)
 198   3                              if (arr[j] > arr[j + 1])
 199   3                                {
 200   4                                      temp = arr[j];
 201   4                                      arr[j] = arr[j + 1];
 202   4                                      arr[j + 1] = temp;
 203   4                                }
 204   3         /*try*/
 205   3         S=(arr[1]+arr[2]+arr[3])/3;
 206   3         sprintf(DisTempData,"L=%6.2f",S);//打印输出结果
 207   3         LCD_Write_String(4,0,DisTempData);       //在液晶屏上显示
 208   3         DelayMs(1000); 
 209   3         }
 210   2      /*------------------------------------------------
 211   2                  后边测距
 212   2      ------------------------------------------------*/ 
 213   2         if(1)
 214   2         {
 215   3         TRIGB=1;      //触发信号是高电平脉冲，宽度大于10us
 216   3         DelayUs2x(10);
 217   3         TRIGB=0;
 218   3         while(!ECHOB); //等待高电平
 219   3         TR0=1;
 220   3         while(ECHOB);  //等待低电平
 221   3         TR0=0;
 222   3         S1=TH0*256+TL0;//取出定时器值高8位和低8位合并
 223   3         S1=S1/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
 224   3         arr[0]=S1;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
 225   3         TH0=0;
 226   3         TL0=0;        //清除定时器0寄存器中的值
 227   3         /*two*/
 228   3         TRIGB=1;       //触发信号是高电平脉冲，宽度大于10us
 229   3         DelayUs2x(10);
 230   3         TRIGB=0;
 231   3         while(!ECHOB); //等待高电平
 232   3         TR0=1;
 233   3         while(ECHOB);  //等待低电平
 234   3         TR0=0;
 235   3         S2=TH0*256+TL0;//取出定时器值高8位和低8位合并
 236   3         S2=S2/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
 237   3         arr[1]=S2;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
 238   3         TH0=0;
 239   3         TL0=0;        //清除定时器0寄存器中的值
 240   3         /*third*/
C51 COMPILER V9.54   MAIN                                                                  05/07/2021 16:45:38 PAGE 5   

 241   3         TRIGB=1;       //触发信号是高电平脉冲，宽度大于10us
 242   3         DelayUs2x(10);
 243   3         TRIGB=0;
 244   3         while(!ECHOB); //等待高电平
 245   3         TR0=1;
 246   3         while(ECHOB);  //等待低电平
 247   3         TR0=0;
 248   3         S3=TH0*256+TL0;//取出定时器值高8位和低8位合并
 249   3         S3=S3/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
 250   3         arr[2]=S3;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
 251   3         TH0=0;
 252   3         TL0=0;        //清除定时器0寄存器中的值
 253   3         /*four*/
 254   3         TRIGB=1;       //触发信号是高电平脉冲，宽度大于10us
 255   3         DelayUs2x(10);
 256   3         TRIGB=0;
 257   3         while(!ECHOB); //等待高电平
 258   3         TR0=1;
 259   3         while(ECHOB);  //等待低电平
 260   3         TR0=0;
 261   3         S4=TH0*256+TL0;//取出定时器值高8位和低8位合并
 262   3         S4=S4/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
 263   3         arr[3]=S4;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
 264   3         TH0=0;
 265   3         TL0=0;        //清除定时器0寄存器中的值
 266   3         /*five*/
 267   3         TRIGB=1;       //触发信号是高电平脉冲，宽度大于10us
 268   3         DelayUs2x(10);
 269   3         TRIGB=0;
 270   3         while(!ECHOB); //等待高电平
 271   3         TR0=1;
 272   3         while(ECHOB);  //等待低电平
 273   3         TR0=0;
 274   3         S5=TH0*256+TL0;//取出定时器值高8位和低8位合并
 275   3         S5=S4/58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
 276   3         arr[4]=S5;      // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
 277   3         TH0=0;
 278   3         TL0=0;        //清除定时器0寄存器中的值
 279   3         /*try*/
 280   3              for (i = 0; i < 5 - 1; i++)
 281   3                      for (j = 0; j < 5 - 1 - i; j++)
 282   3                              if (arr[j] > arr[j + 1])
 283   3                                {
 284   4                                      temp = arr[j];
 285   4                                      arr[j] = arr[j + 1];
 286   4                                      arr[j + 1] = temp;
 287   4                                }
 288   3         /*try*/
 289   3         S=(arr[1]+arr[2]+arr[3])/3;
 290   3         sprintf(DisTempData,"B=%6.2f",S);//打印输出结果
 291   3         LCD_Write_String(8,1,DisTempData);       //在液晶屏上显示
 292   3         DelayMs(1000); 
 293   3                              }                     
 294   2        }
 295   1       }
 296            
 297          
 298          /*------------------------------------------------
 299                           定时器中断子程序
 300          ------------------------------------------------*/
 301          void Timer0_isr(void) interrupt 1
 302          {
C51 COMPILER V9.54   MAIN                                                                  05/07/2021 16:45:38 PAGE 6   

 303   1        ECHOL=0;
 304   1        ECHOB=0;
 305   1        ECHOR=0;
 306   1      }
 307          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1940    ----
   CONSTANT SIZE    =     24    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7      52
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
