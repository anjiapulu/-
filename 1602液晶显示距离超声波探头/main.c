
#include <reg52.h>
#include <stdio.h>
#include <math.h>
#include "1602.h"
#include "delay.h"
//
//sbit TRIGL = P1 ^ 0;
//sbit ECHOL = P1 ^ 1;
//sbit TRIGB = P1 ^ 2;
//sbit ECHOB = P1 ^ 3;
//sbit TRIGR = P1 ^ 4;
//sbit ECHOR = P1 ^ 5;
sbit TRIGL = P2 ^ 0;
sbit ECHOL = P2 ^ 1;
sbit TRIGB = P2 ^ 2;
sbit ECHOB = P2 ^ 3;
sbit TRIGR = P3 ^ 4;
sbit ECHOR = P3 ^ 5; 
unsigned char DisTempData[7];
/*------------------------------------------------
					定时器0初始化
------------------------------------------------*/
void TIM1init(void)
{

	TMOD |= 0x10;//定时器0工作
	TH1 = 0x00;
	TL1 = 0x00;
	ET1 = 1;
	EA = 1;
}
/*------------------------------------------------
					主函数
------------------------------------------------*/
void distance()
{
	/*距离变量*/
	TIM1init();    //初始化定时器0
	LCD_Init();    //初始化LCD
	while (1)
	{
		float S, S1, S2, S3, S4, S5, arr[5], temp;
		int i, j;
		/*------------------------------------------------
					   右边测距
		------------------------------------------------*/
		if (1)
		{
			/*one*/
			TRIGR = 1;       //触发信号是高电平脉冲，宽度大于10us
			DelayUs2x(10);
			TRIGR = 0;
			while (!ECHOR); //等待高电平
			TR1 = 1;
			while (ECHOR);  //等待低电平
			TR1 = 0;
			S1 = TH1 * 256 + TL1;//取出定时器值高8位和低8位合并
			S1 = S1 / 58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
			arr[0] = S1;	     // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
			TH1 = 0;
			TL1 = 0;        //清除定时器0寄存器中的值
			  /*two*/
			TRIGR = 1;       //触发信号是高电平脉冲，宽度大于10us
			DelayUs2x(10);
			TRIGR = 0;
			while (!ECHOR); //等待高电平
			TR1 = 1;
			while (ECHOR);  //等待低电平
			TR1 = 0;
			S2 = TH1 * 256 + TL1;//取出定时器值高8位和低8位合并
			S2 = S2 / 58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
			arr[1] = S2;	     // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
			TH1 = 0;
			TL1 = 0;        //清除定时器0寄存器中的值
			  /*third*/
			TRIGR = 1;       //触发信号是高电平脉冲，宽度大于10us
			DelayUs2x(10);
			TRIGR = 0;
			while (!ECHOR); //等待高电平
			TR1 = 1;
			while (ECHOR);  //等待低电平
			TR1 = 0;
			S3 = TH1 * 256 + TL1;//取出定时器值高8位和低8位合并
			S3 = S3 / 58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
			arr[2] = S3;	     // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
			TH1 = 0;
			TL1 = 0;        //清除定时器0寄存器中的值
			  /*four*/
			TRIGR = 1;       //触发信号是高电平脉冲，宽度大于10us
			DelayUs2x(10);
			TRIGR = 0;
			while (!ECHOR); //等待高电平
			TR1 = 1;
			while (ECHOR);  //等待低电平
			TR1 = 0;
			S4 = TH1 * 256 + TL1;//取出定时器值高8位和低8位合并
			S4 = S4 / 58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
			arr[3] = S4;	     // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
			TH1 = 0;
			TL1 = 0;        //清除定时器0寄存器中的值
			  /*five*/
			TRIGR = 1;       //触发信号是高电平脉冲，宽度大于10us
			DelayUs2x(10);
			TRIGR = 0;
			while (!ECHOR); //等待高电平
			TR1 = 1;
			while (ECHOR);  //等待低电平
			TR1 = 0;
			S5 = TH1 * 256 + TL1;//取出定时器值高8位和低8位合并
			S5 = S4 / 58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
			arr[4] = S5;	     // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
			TH1 = 0;
			TL1 = 0;        //清除定时器0寄存器中的值
			/*try*/

			for (i = 0; i < 5 - 1; i++)
				for (j = 0; j < 5 - 1 - i; j++)
					if (arr[j] > arr[j + 1])
					{
						temp = arr[j];
						arr[j] = arr[j + 1];
						arr[j + 1] = temp;
					}
			/*try*/
			S = (arr[1] + arr[2] + arr[3]) / 3;
			sprintf(DisTempData, "R=%6.2f", S);//打印输出结果
			LCD_Write_String(0, 1, DisTempData);       //在液晶屏上显示
			DelayMs(500);
		}
		/*------------------------------------------------
					左边测距
		------------------------------------------------*/
		if (1)
		{
			/*one*/
			TRIGL = 1;      //触发信号是高电平脉冲，宽度大于10us
			DelayUs2x(10);
			TRIGL = 0;
			while (!ECHOL); //等待高电平
			TR1 = 1;
			while (ECHOL);  //等待低电平
			TR1 = 0;
			S1 = TH1 * 256 + TL1;//取出定时器值高8位和低8位合并
			S1 = S1 / 58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
			arr[0] = S1;	     // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
			TH1 = 0;
			TL1 = 0;        //清除定时器0寄存器中的值
			  /*two*/
			TRIGL = 1;       //触发信号是高电平脉冲，宽度大于10us
			DelayUs2x(10);
			TRIGL = 0;
			while (!ECHOL); //等待高电平
			TR1 = 1;
			while (ECHOL);  //等待低电平
			TR1 = 0;
			S2 = TH1 * 256 + TL1;//取出定时器值高8位和低8位合并
			S2 = S2 / 58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
			arr[1] = S2;	     // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
			TH1 = 0;
			TL1 = 0;        //清除定时器0寄存器中的值
			  /*third*/
			TRIGL = 1;       //触发信号是高电平脉冲，宽度大于10us
			DelayUs2x(10);
			TRIGL = 0;
			while (!ECHOL); //等待高电平
			TR1 = 1;
			while (ECHOL);  //等待低电平
			TR1 = 0;
			S3 = TH1 * 256 + TL1;//取出定时器值高8位和低8位合并
			S3 = S3 / 58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
			arr[2] = S3;	     // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
			TH1 = 0;
			TL1 = 0;        //清除定时器0寄存器中的值
			  /*four*/
			TRIGL = 1;       //触发信号是高电平脉冲，宽度大于10us
			DelayUs2x(10);
			TRIGL = 0;
			while (!ECHOL); //等待高电平
			TR1 = 1;
			while (ECHOL);  //等待低电平
			TR1 = 0;
			S4 = TH1 * 256 + TL1;//取出定时器值高8位和低8位合并
			S4 = S4 / 58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
			arr[3] = S4;	     // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
			TH1 = 0;
			TL1 = 0;        //清除定时器0寄存器中的值
			  /*five*/
			TRIGL = 1;       //触发信号是高电平脉冲，宽度大于10us
			DelayUs2x(10);
			TRIGL = 0;
			while (!ECHOL); //等待高电平
			TR1 = 1;
			while (ECHOL);  //等待低电平
			TR1 = 0;
			S5 = TH1 * 256 + TL1;//取出定时器值高8位和低8位合并
			S5 = S4 / 58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
			arr[4] = S5;	     // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
			TH1 = 0;
			TL1 = 0;        //清除定时器0寄存器中的值
			/*try*/
			for (i = 0; i < 5 - 1; i++)
				for (j = 0; j < 5 - 1 - i; j++)
					if (arr[j] > arr[j + 1])
					{
						temp = arr[j];
						arr[j] = arr[j + 1];
						arr[j + 1] = temp;
					}
			/*try*/
			S = (arr[1] + arr[2] + arr[3]) / 3;
			sprintf(DisTempData, "L=%6.2f", S);//打印输出结果
			LCD_Write_String(4, 0, DisTempData);       //在液晶屏上显示
			DelayMs(1000);
		}
		/*------------------------------------------------
					后边测距
		------------------------------------------------*/
		if (1)
		{
			TRIGB = 1;      //触发信号是高电平脉冲，宽度大于10us
			DelayUs2x(10);
			TRIGB = 0;
			while (!ECHOB); //等待高电平
			TR1 = 1;
			while (ECHOB);  //等待低电平
			TR1 = 0;
			S1 = TH1 * 256 + TL1;//取出定时器值高8位和低8位合并
			S1 = S1 / 58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
			arr[0] = S1;	     // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
			TH1 = 0;
			TL1 = 0;        //清除定时器0寄存器中的值
			  /*two*/
			TRIGB = 1;       //触发信号是高电平脉冲，宽度大于10us
			DelayUs2x(10);
			TRIGB = 0;
			while (!ECHOB); //等待高电平
			TR1 = 1;
			while (ECHOB);  //等待低电平
			TR1 = 0;
			S2 = TH1 * 256 + TL1;//取出定时器值高8位和低8位合并
			S2 = S2 / 58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
			arr[1] = S2;	     // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
			TH1 = 0;
			TL1 = 0;        //清除定时器0寄存器中的值
			  /*third*/
			TRIGB = 1;       //触发信号是高电平脉冲，宽度大于10us
			DelayUs2x(10);
			TRIGB = 0;
			while (!ECHOB); //等待高电平
			TR1 = 1;
			while (ECHOB);  //等待低电平
			TR1 = 0;
			S3 = TH1 * 256 + TL1;//取出定时器值高8位和低8位合并
			S3 = S3 / 58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
			arr[2] = S3;	     // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
			TH1 = 0;
			TL1 = 0;        //清除定时器0寄存器中的值
			  /*four*/
			TRIGB = 1;       //触发信号是高电平脉冲，宽度大于10us
			DelayUs2x(10);
			TRIGB = 0;
			while (!ECHOB); //等待高电平
			TR1 = 1;
			while (ECHOB);  //等待低电平
			TR1 = 0;
			S4 = TH1 * 256 + TL1;//取出定时器值高8位和低8位合并
			S4 = S4 / 58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
			arr[3] = S4;	     // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
			TH1 = 0;
			TL1 = 0;        //清除定时器0寄存器中的值
			  /*five*/
			TRIGB = 1;       //触发信号是高电平脉冲，宽度大于10us
			DelayUs2x(10);
			TRIGB = 0;
			while (!ECHOB); //等待高电平
			TR1 = 1;
			while (ECHOB);  //等待低电平
			TR1 = 0;
			S5 = TH1 * 256 + TL1;//取出定时器值高8位和低8位合并
			S5 = S4 / 58;       //为什么除以58等于厘米，  Y米=（X秒*344）/2
			arr[4] = S5;	     // X秒=（ 2*Y米）/344 -> X秒=0.0058*Y米 -> 厘米=微秒/58 
			TH1 = 0;
			TL1 = 0;        //清除定时器0寄存器中的值
			/*try*/
			for (i = 0; i < 5 - 1; i++)
				for (j = 0; j < 5 - 1 - i; j++)
					if (arr[j] > arr[j + 1])
					{
						temp = arr[j];
						arr[j] = arr[j + 1];
						arr[j + 1] = temp;
					}
			/*try*/
			S = (arr[1] + arr[2] + arr[3]) / 3;
			sprintf(DisTempData, "B=%6.2f", S);//打印输出结果
			LCD_Write_String(8, 1, DisTempData);       //在液晶屏上显示
			DelayMs(1000);
		}
	}
}


/*------------------------------------------------
				 定时器中断子程序
------------------------------------------------*/
void Timer0_isr(void) interrupt 2
{
	ECHOL = 0;
	ECHOB = 0;
	ECHOR = 0;
}